    // const idArray = features.map((current) => {
    //   if (current.layer.id === "unclustered-point") {
    //     return [current.properties.id];
    //   }
    //   if (current.layer.id === "clusters") {
    //     const clusterId = current.properties.cluster_id;
    //     const pointCount = current.properties.point_count;
    //     const clusteredFeatures = getLocationIDSFromCluster(
    //       clusterId,
    //       pointCount,
    //       clusterSource
    //     );
    //     console.log("fromgetclusterleaves", clusteredFeatures);
    //     return clusteredFeatures;
    //   }
    // }) as string[][];

    // console.log(
    //       "idarray",
    //       idArray.flatMap((i) => i).filter((x, i, a) => a.indexOf(x) == i)
    //     );
    // setTimeout(() => {
    //   //hacky solution to deal with clusters
    //   console.log(
    //     "idarray",
    //     idArray.flatMap((i) => i).filter((x, i, a) => a.indexOf(x) == i)
    //   );
    // }, 1);
    // return idArray.flatMap((i) => i);
    // .filter((x, i, a) => a.indexOf(x) == i);






      // const rendered = features.reduce(
    //   (acc: string[], current: MapboxGeoJSONFeature) => {

    //     if (current.layer.id === "unclustered-point") {
    //       dispatch(setClusteredIDS({ strings: [current.properties?.id] }));
    //       // return [...acc, current.properties?.id];
    //     }
    //     if (current.layer.id === "clusters") {
    //       const clusterId = current.properties?.cluster_id;
    //       const pointCount = current.properties?.point_count;
    //       getLocationIDSFromCluster(clusterId, pointCount, clusterSource);
    //       // return acc.concat(clusterMap.clusteredids)
    //     }
    //     // return acc;
    //   },
    //   []
    // );